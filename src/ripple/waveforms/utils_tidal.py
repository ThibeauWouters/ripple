"""Small utility script for shared functions between tidal waveforms, especially for NRTidalv2"""

import jax
import jax.numpy as jnp
from ..typing import Array
from ..constants import EulerGamma, gt, m_per_Mpc, C, PI, TWO_PI, MSUN, MRSUN, G

def universal_relation(coeffs: Array, x: float):
    """Applies the general formula of a universal relationship, which is a quartic polynomial.

    Args:
        coeffs (Array): Array of coefficients for the quartic polynomial, starting from the constant term and going to the fourth order.
        x (float): Variable of quartic polynomial

    Returns:
        float: Result of universal relation
    """
    return coeffs[0] + coeffs[1] * x + coeffs[2] * (x ** 2) + coeffs[3] * (x ** 3) + coeffs[4] * (x ** 4)

def get_quadparam_octparam(lambda_: float) -> tuple[float, float]:
    """Compute the quadrupole and octupole parameter by checking the value of lambda and choosing the right subroutine.
    If lambda is smaller than 1, we make use of the fit formula as given by the LAL source code. Otherwise, we rely on the equations of
    the NRTidalv2 paper to get these parameters.

    Args:
        lambda_ (float): Tidal deformability of object.

    Returns:
        tuple[float, float]: Quadrupole and octupole parameters.
    """
    
    # Check if lambda is low or not, and choose right subroutine
    is_low_lambda = lambda_ < 1
    return jax.lax.cond(is_low_lambda, _get_quadparam_octparam_low, _get_quadparam_octparam_high, lambda_)

def _get_quadparam_octparam_low(lambda_: float) -> tuple[float, float]:
    """
    Computes quadparameter, see eq (28) of NRTidalv2 paper and also LALSimUniversalRelations.c of lalsuite
    
    Version for lambdas smaller than 1.
    
    LALsuite has an extension where a separate formula is used for lambdas smaller than one, and another formula is used for lambdas larger than one.
    Args:
        lambda_: tidal deformability

    Returns:
        quadparam: Quadrupole coefficient called C_Q in NRTidalv2 paper
        octparam: Octupole coefficient called C_Oc in NRTidalv2 paper
    """
    
    # Coefficients of universal relation
    oct_coeffs = [0.003131, 2.071, -0.7152, 0.2458, -0.03309]
    
    # Extension of the fit in the range lambda2 = [0,1.] so that the BH limit is enforced, lambda2bar->0 gives quadparam->1. and the junction with the universal relation is smooth, of class C2
    quadparam = 1. + lambda_ * (0.427688866723244 + lambda_ * (-0.324336526985068 + lambda_ * 0.1107439432180572))
    log_quadparam = jnp.log(quadparam)
        
    # Compute octparam:
    log_octparam = universal_relation(oct_coeffs, log_quadparam)
    octparam = jnp.exp(log_octparam)

    return quadparam, octparam

def _get_quadparam_octparam_high(lambda_: float) -> tuple[float, float]:
    """
    Computes quadparameter, see eq (28) of NRTidalv2 paper and also LALSimUniversalRelations.c of lalsuite
    
    Version for lambdas greater than 1.
    
    LALsuite has an extension where a separate formula is used for lambdas smaller than one, and another formula is used for lambdas larger than one.
    Args:
        lambda_: tidal deformability

    Returns:
        quadparam: Quadrupole coefficient called C_Q in NRTidalv2 paper
        octparam: Octupole coefficient called C_Oc in NRTidalv2 paper
    """
    
    # Coefficients of universal relation
    quad_coeffs = [0.1940, 0.09163, 0.04812, -4.283e-3, 1.245e-4]
    oct_coeffs = [0.003131, 2.071, -0.7152, 0.2458, -0.03309]
        
    # High lambda (above 1): use universal relation
    log_lambda = jnp.log(lambda_)
    log_quadparam = universal_relation(quad_coeffs, log_lambda)
    
    # Compute octparam:
    log_octparam = universal_relation(oct_coeffs, log_quadparam)

    quadparam = jnp.exp(log_quadparam)
    octparam = jnp.exp(log_octparam)

    return quadparam, octparam

def get_kappa(theta: Array) -> float:
    """Computes the tidal deformability parameter kappa according to equation (8) of the NRTidalv2 paper.

    Args:
        theta (Array): Intrinsic parameters m1, m2, chi1, chi2, lambda1, lambda2

    Returns:
        float: kappa_eff^T from equation (8) of NRTidalv2 paper.
    """
    
    # Auxiliary variables
    m1, m2, _, _, lambda1, lambda2 = theta
    M = m1 + m2
    X1 = m1 / M
    X2 = m2 / M

    # Get kappa
    term1 = (1.0 + 12.0 * X2 / X1) * (X1 ** 5.0) * lambda1
    term2 = (1.0 + 12.0 * X1 / X2) * (X2 ** 5.0) * lambda2
    kappa = (3./13.) * (term1 + term2)
    
    return kappa 

def get_amp0_lal(M: float, distance: float):
    """Get the amp0 prefactor as defined in LAL in LALSimIMRPhenomD, line 331. 

    Args:
        M (float): Total mass in solar masses
        distance (float): Distance to the source in Mpc.

    Returns:
        float: amp0 from LAL.
    """
    amp0 = 2. * jnp.sqrt(5. / (64. * PI)) * M * MRSUN * M * gt / distance
    return amp0


# def planck_taper(t: Array, t1: float, t2: float) -> Array:
#     """Function to compute the Planck taper window between t1 and t2.

#     Args:
#         t (Array): Times at which the Planck taper has to be computed.
#         t1 (float): Start of Planck taper.
#         t2 (float): End of Planck taper.

#     Returns:
#         Array: Planck taper A_P
#     """

#     # Planck taper consists of three parts:
#     begin = jnp.zeros_like(t)
#     end = jnp.ones_like(t)
#     middle = 1. / (jnp.exp((t2 - t1)/(t - t1) + (t2 - t1)/(t - t2)) + 1.)

#     # Build the taper from the three parts with step functions
#     taper = jnp.heaviside(t1 - t, 1) * begin \
#             + jnp.heaviside(t - t1, 1) * jnp.heaviside(t2 - t, 1) * middle \
#             + jnp.heaviside(t - t2, 1) * end

#     return taper

# def get_planck_taper(f: Array, f_merger: float) -> Array:
#     """Get the Planck taper for the purpose of NRTidalv2, namely by applying it in the window [f_merger, 1.2f_merger]

#     Args:
#         f (Array): Frequency grid at which the GW is being computed.
#         f_merger (float): Merger frequency in Hz.

#     Returns:
#         Array: Planck taper for NRTidalv2
#     """
#     return 1.0 - planck_taper(f, f_merger, 1.2 * f_merger)

### The code below to compute the Planck taper is obtained from gwfast (https://github.com/CosmoStatGW/gwfast/blob/ccde00e644682639aa8c9cbae323e42718fd61ca/gwfast/waveforms.py#L1332)
@jax.custom_jvp
def get_planck_taper(x, y):
    # Terminate the waveform at 1.2 times the merger frequency
    a=1.2
    yp = a*y
    planck_taper = jnp.where(x < y, 1., jnp.where(x > yp, 0., 1. - 1./(jnp.exp((yp - y)/(x - y) + (yp - y)/(x - yp)) + 1.)))

    return planck_taper

def get_planck_taper_der(x,y):
    # Terminate the waveform at 1.2 times the merger frequency
    a = 1.2
    yp = a*y
    tangent_out = jnp.where(x < y, 0., jnp.where(x > yp, 0., jnp.exp((yp - y)/(x - y) + (yp - y)/(x - yp))*((-1.+a)/(x-y) + (-1.+a)/(x-yp) + (-y+yp)/((x-y)**2) + 1.2*(-y+yp)/((x-yp)**2))/((jnp.exp((yp - y)/(x - y) + (yp - y)/(x - yp)) + 1.)**2)))
    tangent_out = jnp.nan_to_num(tangent_out)
    return tangent_out
get_planck_taper.defjvps(None, lambda y_dot, primal_out, x, y: get_planck_taper_der(x,y) * y_dot)

def compactness(Lambda):
    ln_Lambda = jnp.log(Lambda)
    return 0.371 - 3.91 * 10**(-2) * ln_Lambda + 1.056 * 10**(-3) * ln_Lambda**2

def kappa_eff(m1, m2, L1, L2):
    """
    m1, m2: masses of the two objects in solar mass
    L1, L2: lambdas of the two objects
    """
    M = m1 + m2
    X1 = m1/M
    X2 = m2/M
    term1 = (1.0 + 12.0 * X2 / X1) * (X1 ** 5.0) * L1
    term2 = (1.0 + 12.0 * X1 / X2) * (X2 ** 5.0) * L2
    kappa = (3./13.) * (term1 + term2)
    return kappa

def f_ISCO(m1, m2):
    """
    m1, m2: masses of the two objects in solar mass
    """
    m1 = m1 * MSUN
    m2 = m2 * MSUN
    M = m1 + m2
    ## Equation 12 of Agathos et al ##
    return C**3 / (6**(3/2) * G * PI * M)

def f_contact(m1, m2, R1, R2):
    """
    m1, m2: masses of the two objects in solar mass
    R1, R2: radii of the two objects in km
    """
    m1 = m1*MSUN
    m2 = m2*MSUN
    M = m1 + m2
    R = R1*1000 + R2*1000
    M = M * G / C**3
    R = R/C
    ## Eqation 14 of Agathos et al ##
    return 1/PI * (M / R**3)**(1/2)

def f_RLO(m1, m2):
    """
    m1, m2: masses of the two objects in solar mass
    """
    M = m1+m2
    m1M = m1/MSUN
    m2M = m2/MSUN
    ## Equation 7 of Primordial black holes or else? ##
    return -26.9 -35.5*m1 -3.02*m1**2 + 1690*m2 - 575*m2**2

def f_merger(m1, m2, L1, L2):
    """
    m1, m2: masses of the two objects in solar mass
    """
    M = m1+m2
    M_s = M * (G * MSUN/c**3)
    X1 = m1/M
    X2 = m2/M
    q = m1/m2
    kappa = kappa_eff(m1, m2, L1, L2)

    #Initialize coefficients
    omega_0 = 0.3586
    n_1 = 3.35411203e-2
    n_2 = 4.31460284e-5
    d_1 = 7.54224145e-2
    d_2 = 2.23626859e-4
    #Calculate each term 
    prefactor = omega_0 * jnp.sqrt(X2/X1)
    numerator =   1 + n_1 * kappa + n_2 * kappa**2
    denominator = 1 + d_1 * kappa + d_2 * kappa**2
    #Calculate omega merger
    omega_merger = prefactor * (numerator/denominator)
    freq_merger = omega_merger / M_s / (2*jnp.pi)
    return freq_merger
        

def get_tidal_amplitude(x: Array, theta: Array, kappa: float, distance: float =1):
    """Get the tidal amplitude corrections as given in equation (24) of the NRTidal paper.

    Args:
        x (Array): Angular frequency, in particular, x = (pi M f)^(2/3)
        theta (Array): Intrinsic parameters (mass1, mass2, chi1, chi2, lambda1, lambda2)
        kappa (float): Tidal parameter kappa
        distance (float, optional): Distance to the source in Mpc.

    Returns:
        Array: Tidal amplitude corrections A_T from NRTidalv2 paper.
    """
    
    # Mass variables
    m1, m2, _, _, _, _ = theta 
    M = m1 + m2
    m1_s = m1 * gt
    m2_s = m2 * gt
    
    # Convert distance to meters
    distance *= m_per_Mpc
    
    # Pade approximant
    n1   = 4.157407407407407
    n289 = 2519.111111111111
    d    = 13477.8073677
    num = 1.0 + n1 * x + n289 * x ** 2.89
    den = 1.0 + d * x ** 4.
    poly = num / den
    
    # Prefactors are taken from lal source code
    prefac = - 9.0 * kappa
    ampT = prefac * x ** (13. / 4.) * poly
    amp0 = get_amp0_lal(M, distance)
    ampT *= amp0 * 2 * jnp.sqrt(PI / 5)
    
    return ampT 

def _get_spin_induced_quadrupole_phase_coeff(lambda_: float, mass: float) -> float:
    """Compute the quantity from equation (11) from http://arxiv.org/abs/1503.05405

    Args:
        lambda_ (float): Tidal deformability of object
        mass (float): Mass of object in solar masses

    Returns:
        float: a(m) 
    """
    is_low_lambda = lambda_ < 1
    return jax.lax.cond(is_low_lambda, _get_spin_induced_quadrupole_phase_coeff_low, _get_spin_induced_quadrupole_phase_coeff_high, lambda_)
        

def _get_spin_induced_quadrupole_phase_coeff_low(lambda_: float) -> float:
    """Compute the quantity from equation (11) from http://arxiv.org/abs/1503.05405

    Args:
        lambda_ (float): Tidal deformability of object
        mass (float): Mass of object in solar masses

    Returns:
        float: a(m) as defined in https://git.ligo.org/thibeau.wouters/bonz_marlinde/-/blob/main/UniversalRelation/FitUniversalRelation.ipynb?ref_type=heads (fit)
    """
    coeffs = jnp.array([1.0, 0.32812816173650255, -0.16209486695933736, 0.05219418106960124, -0.006406318945489099])
    a = universal_relation(coeffs, lambda_)
    return a

def _get_spin_induced_quadrupole_phase_coeff_high(lambda_: float) -> float:
    """Compute the quantity from equation (11) from http://arxiv.org/abs/1503.05405

    Args:
        lambda_ (float): Tidal deformability of object
        mass (float): Mass of object in solar masses

    Returns:
        float: a(m) as defined in equation (11) of http://arxiv.org/abs/1503.05405
    """
    
    # Auxiliary parameter:
    # TODO what if lambda is zero or negative?
    x = jnp.log(lambda_)
    coeffs = jnp.array([0.194, 0.0936, 0.0474, -4.21e-3, 1.23e-4])
    
    ln_a = universal_relation(coeffs, x)
    a = jnp.exp(ln_a)
        
    return a

def get_spin_induced_quadrupole_phase(v: Array, theta: Array) -> Array:
    """Computes the contribution to the phase from the spin-induced quadrupole moment

    Args:
        v (Array): Array of velocities, that is, v = (pi M f)^(1/3)
        theta (Array): Array of parameters (m1, m2, chi1, chi2, lambda1, lambda2, a1, a2)   

    Returns:
        Array: Phase contribution from spin-induced quadrupole moment
    """
    # See http://arxiv.org/   abs/1503.05405, around eq (11)
    
    # Get parameters and auxiliary variables
    m1, m2, chi1, chi2, lambda1, lambda2, a1, a2 = theta 
    M  = m1 + m2
    X1 = m1 / M
    X2 = m2 / M
    eta = m1 * m2 / (M ** 2.0)
    
    # Compute the spin-induced quadrupole phase if it is not already given (NOTE this is assuming aligned spin)
    if a1 == jnp.inf:
        a1 = _get_spin_induced_quadrupole_phase_coeff(lambda1, m1)
        a2 = _get_spin_induced_quadrupole_phase_coeff(lambda2, m2)
    sigma_qm_1 = 5 * a1 * (X1 ** 2) * chi1 ** 2
    sigma_qm_2 = 5 * a2 * (X2 ** 2) * chi2 ** 2
    
    sigma_qm = sigma_qm_1 + sigma_qm_2
    psi_qm = - (30 / (128 * eta)) * sigma_qm / v
    
    return psi_qm

def get_TaylorF2_taper(f: Array, theta: Array, stop: str) -> Array:
    """
    Get a tapering of the waveform as used in the TaylorF2 variants

    Args:
        f (Array): Frequency array
        theta (Array): Array of intrinsic parameters, including lambdas
        stop (str): String denoting which stopping frequency computation to use

    Raises:
        ValueError: In case the stop string is not supported

    Returns:
        Array: An array to be used as the taper, i.e. the prefactor before the amplitude. 
    """
    
    try:
        m1, m2, _, _, lambda1, lambda2, _, _ = theta
    except Exception:
        m1, m2, _, _, lambda1, lambda2 = theta
    
    supported = ["contact", "RLO", "merger", "ISCO", "None"]
    if stop not in supported:
        space = " "
        raise ValueError(f"Stopping frequency {stop} not supported. Supported values are {supported.join(space)}")
    
    # Select a stopping frequency
    if stop == "contact":
        C1 = compactness(lambda1)
        C2 = compactness(lambda2)
        R1 = m1/C1
        R2 = m2/C2
        f_stop = f_contact(m1, m2, R1, R2)
    elif stop == "RLO":
        f_stop = f_RLO(m1, m2)
    elif stop == "merger":
        f_stop = f_merger(m1, m2, lambda1, lambda2)
    elif stop == "ISCO":
        f_stop = f_ISCO(m1, m2)
    else:
        A_P = jnp.ones_like(f)
        return A_P
    
    A_P = get_planck_taper(f, f_stop)
    
    return A_P